// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gen

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Changelog() ChangelogResolver
	ChangelogChange() ChangelogChangeResolver
	ChangelogChangeResultType() ChangelogChangeResultTypeResolver
	ChangelogResultType() ChangelogResultTypeResolver
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Changelog struct {
		Changes           func(childComplexity int) int
		ChangesConnection func(childComplexity int, offset *int, limit *int, q *string, sort []*ChangelogChangeSortType, filter *ChangelogChangeFilterType) int
		ChangesIds        func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		Date              func(childComplexity int) int
		Entity            func(childComplexity int) int
		EntityID          func(childComplexity int) int
		ID                func(childComplexity int) int
		PrincipalID       func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		UpdatedBy         func(childComplexity int) int
	}

	ChangelogChange struct {
		Column    func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		ID        func(childComplexity int) int
		Log       func(childComplexity int) int
		LogID     func(childComplexity int) int
		NewValue  func(childComplexity int) int
		OldValue  func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		UpdatedBy func(childComplexity int) int
	}

	ChangelogChangeResultAggregations struct {
		ColumnMax   func(childComplexity int) int
		ColumnMin   func(childComplexity int) int
		NewValueMax func(childComplexity int) int
		NewValueMin func(childComplexity int) int
		OldValueMax func(childComplexity int) int
		OldValueMin func(childComplexity int) int
	}

	ChangelogChangeResultType struct {
		Aggregations func(childComplexity int) int
		Count        func(childComplexity int) int
		Items        func(childComplexity int) int
	}

	ChangelogResultAggregations struct {
		EntityIDMax    func(childComplexity int) int
		EntityIDMin    func(childComplexity int) int
		EntityMax      func(childComplexity int) int
		EntityMin      func(childComplexity int) int
		PrincipalIDMax func(childComplexity int) int
		PrincipalIDMin func(childComplexity int) int
	}

	ChangelogResultType struct {
		Aggregations func(childComplexity int) int
		Count        func(childComplexity int) int
		Items        func(childComplexity int) int
	}

	Mutation struct {
		CreateChangelog           func(childComplexity int, input map[string]interface{}) int
		CreateChangelogChange     func(childComplexity int, input map[string]interface{}) int
		DeleteAllChangelogChanges func(childComplexity int) int
		DeleteAllChangelogs       func(childComplexity int) int
		DeleteChangelog           func(childComplexity int, id string) int
		DeleteChangelogChange     func(childComplexity int, id string) int
		UpdateChangelog           func(childComplexity int, id string, input map[string]interface{}) int
		UpdateChangelogChange     func(childComplexity int, id string, input map[string]interface{}) int
	}

	Query struct {
		Changelog        func(childComplexity int, id *string, q *string, filter *ChangelogFilterType) int
		ChangelogChange  func(childComplexity int, id *string, q *string, filter *ChangelogChangeFilterType) int
		ChangelogChanges func(childComplexity int, offset *int, limit *int, q *string, sort []*ChangelogChangeSortType, filter *ChangelogChangeFilterType) int
		Changelogs       func(childComplexity int, offset *int, limit *int, q *string, sort []*ChangelogSortType, filter *ChangelogFilterType) int
		_entities        func(childComplexity int, representations []interface{}) int
		_service         func(childComplexity int) int
	}

	_Service struct {
		Sdl func(childComplexity int) int
	}
}

type ChangelogResolver interface {
	Changes(ctx context.Context, obj *Changelog) ([]*ChangelogChange, error)

	ChangesIds(ctx context.Context, obj *Changelog) ([]string, error)
	ChangesConnection(ctx context.Context, obj *Changelog, offset *int, limit *int, q *string, sort []*ChangelogChangeSortType, filter *ChangelogChangeFilterType) (*ChangelogChangeResultType, error)
}
type ChangelogChangeResolver interface {
	Log(ctx context.Context, obj *ChangelogChange) (*Changelog, error)
}
type ChangelogChangeResultTypeResolver interface {
	Items(ctx context.Context, obj *ChangelogChangeResultType) ([]*ChangelogChange, error)
	Count(ctx context.Context, obj *ChangelogChangeResultType) (int, error)
	Aggregations(ctx context.Context, obj *ChangelogChangeResultType) (*ChangelogChangeResultAggregations, error)
}
type ChangelogResultTypeResolver interface {
	Items(ctx context.Context, obj *ChangelogResultType) ([]*Changelog, error)
	Count(ctx context.Context, obj *ChangelogResultType) (int, error)
	Aggregations(ctx context.Context, obj *ChangelogResultType) (*ChangelogResultAggregations, error)
}
type MutationResolver interface {
	CreateChangelogChange(ctx context.Context, input map[string]interface{}) (*ChangelogChange, error)
	UpdateChangelogChange(ctx context.Context, id string, input map[string]interface{}) (*ChangelogChange, error)
	DeleteChangelogChange(ctx context.Context, id string) (*ChangelogChange, error)
	DeleteAllChangelogChanges(ctx context.Context) (bool, error)
	CreateChangelog(ctx context.Context, input map[string]interface{}) (*Changelog, error)
	UpdateChangelog(ctx context.Context, id string, input map[string]interface{}) (*Changelog, error)
	DeleteChangelog(ctx context.Context, id string) (*Changelog, error)
	DeleteAllChangelogs(ctx context.Context) (bool, error)
}
type QueryResolver interface {
	_service(ctx context.Context) (*_Service, error)
	_entities(ctx context.Context, representations []interface{}) ([]_Entity, error)
	ChangelogChange(ctx context.Context, id *string, q *string, filter *ChangelogChangeFilterType) (*ChangelogChange, error)
	ChangelogChanges(ctx context.Context, offset *int, limit *int, q *string, sort []*ChangelogChangeSortType, filter *ChangelogChangeFilterType) (*ChangelogChangeResultType, error)
	Changelog(ctx context.Context, id *string, q *string, filter *ChangelogFilterType) (*Changelog, error)
	Changelogs(ctx context.Context, offset *int, limit *int, q *string, sort []*ChangelogSortType, filter *ChangelogFilterType) (*ChangelogResultType, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Changelog.changes":
		if e.complexity.Changelog.Changes == nil {
			break
		}

		return e.complexity.Changelog.Changes(childComplexity), true

	case "Changelog.changesConnection":
		if e.complexity.Changelog.ChangesConnection == nil {
			break
		}

		args, err := ec.field_Changelog_changesConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Changelog.ChangesConnection(childComplexity, args["offset"].(*int), args["limit"].(*int), args["q"].(*string), args["sort"].([]*ChangelogChangeSortType), args["filter"].(*ChangelogChangeFilterType)), true

	case "Changelog.changesIds":
		if e.complexity.Changelog.ChangesIds == nil {
			break
		}

		return e.complexity.Changelog.ChangesIds(childComplexity), true

	case "Changelog.createdAt":
		if e.complexity.Changelog.CreatedAt == nil {
			break
		}

		return e.complexity.Changelog.CreatedAt(childComplexity), true

	case "Changelog.createdBy":
		if e.complexity.Changelog.CreatedBy == nil {
			break
		}

		return e.complexity.Changelog.CreatedBy(childComplexity), true

	case "Changelog.date":
		if e.complexity.Changelog.Date == nil {
			break
		}

		return e.complexity.Changelog.Date(childComplexity), true

	case "Changelog.entity":
		if e.complexity.Changelog.Entity == nil {
			break
		}

		return e.complexity.Changelog.Entity(childComplexity), true

	case "Changelog.entityID":
		if e.complexity.Changelog.EntityID == nil {
			break
		}

		return e.complexity.Changelog.EntityID(childComplexity), true

	case "Changelog.id":
		if e.complexity.Changelog.ID == nil {
			break
		}

		return e.complexity.Changelog.ID(childComplexity), true

	case "Changelog.principalID":
		if e.complexity.Changelog.PrincipalID == nil {
			break
		}

		return e.complexity.Changelog.PrincipalID(childComplexity), true

	case "Changelog.type":
		if e.complexity.Changelog.Type == nil {
			break
		}

		return e.complexity.Changelog.Type(childComplexity), true

	case "Changelog.updatedAt":
		if e.complexity.Changelog.UpdatedAt == nil {
			break
		}

		return e.complexity.Changelog.UpdatedAt(childComplexity), true

	case "Changelog.updatedBy":
		if e.complexity.Changelog.UpdatedBy == nil {
			break
		}

		return e.complexity.Changelog.UpdatedBy(childComplexity), true

	case "ChangelogChange.column":
		if e.complexity.ChangelogChange.Column == nil {
			break
		}

		return e.complexity.ChangelogChange.Column(childComplexity), true

	case "ChangelogChange.createdAt":
		if e.complexity.ChangelogChange.CreatedAt == nil {
			break
		}

		return e.complexity.ChangelogChange.CreatedAt(childComplexity), true

	case "ChangelogChange.createdBy":
		if e.complexity.ChangelogChange.CreatedBy == nil {
			break
		}

		return e.complexity.ChangelogChange.CreatedBy(childComplexity), true

	case "ChangelogChange.id":
		if e.complexity.ChangelogChange.ID == nil {
			break
		}

		return e.complexity.ChangelogChange.ID(childComplexity), true

	case "ChangelogChange.log":
		if e.complexity.ChangelogChange.Log == nil {
			break
		}

		return e.complexity.ChangelogChange.Log(childComplexity), true

	case "ChangelogChange.logId":
		if e.complexity.ChangelogChange.LogID == nil {
			break
		}

		return e.complexity.ChangelogChange.LogID(childComplexity), true

	case "ChangelogChange.newValue":
		if e.complexity.ChangelogChange.NewValue == nil {
			break
		}

		return e.complexity.ChangelogChange.NewValue(childComplexity), true

	case "ChangelogChange.oldValue":
		if e.complexity.ChangelogChange.OldValue == nil {
			break
		}

		return e.complexity.ChangelogChange.OldValue(childComplexity), true

	case "ChangelogChange.updatedAt":
		if e.complexity.ChangelogChange.UpdatedAt == nil {
			break
		}

		return e.complexity.ChangelogChange.UpdatedAt(childComplexity), true

	case "ChangelogChange.updatedBy":
		if e.complexity.ChangelogChange.UpdatedBy == nil {
			break
		}

		return e.complexity.ChangelogChange.UpdatedBy(childComplexity), true

	case "ChangelogChangeResultAggregations.columnMax":
		if e.complexity.ChangelogChangeResultAggregations.ColumnMax == nil {
			break
		}

		return e.complexity.ChangelogChangeResultAggregations.ColumnMax(childComplexity), true

	case "ChangelogChangeResultAggregations.columnMin":
		if e.complexity.ChangelogChangeResultAggregations.ColumnMin == nil {
			break
		}

		return e.complexity.ChangelogChangeResultAggregations.ColumnMin(childComplexity), true

	case "ChangelogChangeResultAggregations.newValueMax":
		if e.complexity.ChangelogChangeResultAggregations.NewValueMax == nil {
			break
		}

		return e.complexity.ChangelogChangeResultAggregations.NewValueMax(childComplexity), true

	case "ChangelogChangeResultAggregations.newValueMin":
		if e.complexity.ChangelogChangeResultAggregations.NewValueMin == nil {
			break
		}

		return e.complexity.ChangelogChangeResultAggregations.NewValueMin(childComplexity), true

	case "ChangelogChangeResultAggregations.oldValueMax":
		if e.complexity.ChangelogChangeResultAggregations.OldValueMax == nil {
			break
		}

		return e.complexity.ChangelogChangeResultAggregations.OldValueMax(childComplexity), true

	case "ChangelogChangeResultAggregations.oldValueMin":
		if e.complexity.ChangelogChangeResultAggregations.OldValueMin == nil {
			break
		}

		return e.complexity.ChangelogChangeResultAggregations.OldValueMin(childComplexity), true

	case "ChangelogChangeResultType.aggregations":
		if e.complexity.ChangelogChangeResultType.Aggregations == nil {
			break
		}

		return e.complexity.ChangelogChangeResultType.Aggregations(childComplexity), true

	case "ChangelogChangeResultType.count":
		if e.complexity.ChangelogChangeResultType.Count == nil {
			break
		}

		return e.complexity.ChangelogChangeResultType.Count(childComplexity), true

	case "ChangelogChangeResultType.items":
		if e.complexity.ChangelogChangeResultType.Items == nil {
			break
		}

		return e.complexity.ChangelogChangeResultType.Items(childComplexity), true

	case "ChangelogResultAggregations.entityIDMax":
		if e.complexity.ChangelogResultAggregations.EntityIDMax == nil {
			break
		}

		return e.complexity.ChangelogResultAggregations.EntityIDMax(childComplexity), true

	case "ChangelogResultAggregations.entityIDMin":
		if e.complexity.ChangelogResultAggregations.EntityIDMin == nil {
			break
		}

		return e.complexity.ChangelogResultAggregations.EntityIDMin(childComplexity), true

	case "ChangelogResultAggregations.entityMax":
		if e.complexity.ChangelogResultAggregations.EntityMax == nil {
			break
		}

		return e.complexity.ChangelogResultAggregations.EntityMax(childComplexity), true

	case "ChangelogResultAggregations.entityMin":
		if e.complexity.ChangelogResultAggregations.EntityMin == nil {
			break
		}

		return e.complexity.ChangelogResultAggregations.EntityMin(childComplexity), true

	case "ChangelogResultAggregations.principalIDMax":
		if e.complexity.ChangelogResultAggregations.PrincipalIDMax == nil {
			break
		}

		return e.complexity.ChangelogResultAggregations.PrincipalIDMax(childComplexity), true

	case "ChangelogResultAggregations.principalIDMin":
		if e.complexity.ChangelogResultAggregations.PrincipalIDMin == nil {
			break
		}

		return e.complexity.ChangelogResultAggregations.PrincipalIDMin(childComplexity), true

	case "ChangelogResultType.aggregations":
		if e.complexity.ChangelogResultType.Aggregations == nil {
			break
		}

		return e.complexity.ChangelogResultType.Aggregations(childComplexity), true

	case "ChangelogResultType.count":
		if e.complexity.ChangelogResultType.Count == nil {
			break
		}

		return e.complexity.ChangelogResultType.Count(childComplexity), true

	case "ChangelogResultType.items":
		if e.complexity.ChangelogResultType.Items == nil {
			break
		}

		return e.complexity.ChangelogResultType.Items(childComplexity), true

	case "Mutation.createChangelog":
		if e.complexity.Mutation.CreateChangelog == nil {
			break
		}

		args, err := ec.field_Mutation_createChangelog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateChangelog(childComplexity, args["input"].(map[string]interface{})), true

	case "Mutation.createChangelogChange":
		if e.complexity.Mutation.CreateChangelogChange == nil {
			break
		}

		args, err := ec.field_Mutation_createChangelogChange_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateChangelogChange(childComplexity, args["input"].(map[string]interface{})), true

	case "Mutation.deleteAllChangelogChanges":
		if e.complexity.Mutation.DeleteAllChangelogChanges == nil {
			break
		}

		return e.complexity.Mutation.DeleteAllChangelogChanges(childComplexity), true

	case "Mutation.deleteAllChangelogs":
		if e.complexity.Mutation.DeleteAllChangelogs == nil {
			break
		}

		return e.complexity.Mutation.DeleteAllChangelogs(childComplexity), true

	case "Mutation.deleteChangelog":
		if e.complexity.Mutation.DeleteChangelog == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChangelog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChangelog(childComplexity, args["id"].(string)), true

	case "Mutation.deleteChangelogChange":
		if e.complexity.Mutation.DeleteChangelogChange == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChangelogChange_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChangelogChange(childComplexity, args["id"].(string)), true

	case "Mutation.updateChangelog":
		if e.complexity.Mutation.UpdateChangelog == nil {
			break
		}

		args, err := ec.field_Mutation_updateChangelog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChangelog(childComplexity, args["id"].(string), args["input"].(map[string]interface{})), true

	case "Mutation.updateChangelogChange":
		if e.complexity.Mutation.UpdateChangelogChange == nil {
			break
		}

		args, err := ec.field_Mutation_updateChangelogChange_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChangelogChange(childComplexity, args["id"].(string), args["input"].(map[string]interface{})), true

	case "Query.changelog":
		if e.complexity.Query.Changelog == nil {
			break
		}

		args, err := ec.field_Query_changelog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Changelog(childComplexity, args["id"].(*string), args["q"].(*string), args["filter"].(*ChangelogFilterType)), true

	case "Query.changelogChange":
		if e.complexity.Query.ChangelogChange == nil {
			break
		}

		args, err := ec.field_Query_changelogChange_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChangelogChange(childComplexity, args["id"].(*string), args["q"].(*string), args["filter"].(*ChangelogChangeFilterType)), true

	case "Query.changelogChanges":
		if e.complexity.Query.ChangelogChanges == nil {
			break
		}

		args, err := ec.field_Query_changelogChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChangelogChanges(childComplexity, args["offset"].(*int), args["limit"].(*int), args["q"].(*string), args["sort"].([]*ChangelogChangeSortType), args["filter"].(*ChangelogChangeFilterType)), true

	case "Query.changelogs":
		if e.complexity.Query.Changelogs == nil {
			break
		}

		args, err := ec.field_Query_changelogs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Changelogs(childComplexity, args["offset"].(*int), args["limit"].(*int), args["q"].(*string), args["sort"].([]*ChangelogSortType), args["filter"].(*ChangelogFilterType)), true

	case "Query._entities":
		if e.complexity.Query._entities == nil {
			break
		}

		args, err := ec.field_Query__entities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._entities(childComplexity, args["representations"].([]interface{})), true

	case "Query._service":
		if e.complexity.Query._service == nil {
			break
		}

		return e.complexity.Query._service(childComplexity), true

	case "_Service.sdl":
		if e.complexity._Service.Sdl == nil {
			break
		}

		return e.complexity._Service.Sdl(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `# This schema is generated, please don't update it manually

scalar Time

scalar _Any

schema {
  query: Query
  mutation: Mutation
}

type Query {
  _service: _Service!
  _entities(representations: [_Any!]!): [_Entity]!
  changelogChange(id: ID, q: String, filter: ChangelogChangeFilterType): ChangelogChange
  changelogChanges(offset: Int, limit: Int = 30, q: String, sort: [ChangelogChangeSortType!], filter: ChangelogChangeFilterType): ChangelogChangeResultType!
  changelog(id: ID, q: String, filter: ChangelogFilterType): Changelog
  changelogs(offset: Int, limit: Int = 30, q: String, sort: [ChangelogSortType!], filter: ChangelogFilterType): ChangelogResultType!
}

type Mutation {
  createChangelogChange(input: ChangelogChangeCreateInput!): ChangelogChange!
  updateChangelogChange(id: ID!, input: ChangelogChangeUpdateInput!): ChangelogChange!
  deleteChangelogChange(id: ID!): ChangelogChange!
  deleteAllChangelogChanges: Boolean!
  createChangelog(input: ChangelogCreateInput!): Changelog!
  updateChangelog(id: ID!, input: ChangelogUpdateInput!): Changelog!
  deleteChangelog(id: ID!): Changelog!
  deleteAllChangelogs: Boolean!
}

enum ObjectSortType {
  ASC
  DESC
}

enum ChangelogType {
  CREATED
  UPDATED
  DELETED
}

type ChangelogChange {
  id: ID!
  column: String!
  oldValue: String
  newValue: String
  log: Changelog
  logId: ID
  updatedAt: Time
  createdAt: Time!
  updatedBy: ID
  createdBy: ID
}

type Changelog {
  id: ID!
  entity: String!
  entityID: String!
  principalID: String
  type: ChangelogType!
  date: Time!
  changes: [ChangelogChange!]!
  updatedAt: Time
  createdAt: Time!
  updatedBy: ID
  createdBy: ID
  changesIds: [ID!]!
  changesConnection(offset: Int, limit: Int = 30, q: String, sort: [ChangelogChangeSortType!], filter: ChangelogChangeFilterType): ChangelogChangeResultType!
}

input ChangelogChangeCreateInput {
  id: ID
  column: String!
  oldValue: String
  newValue: String
  logId: ID
}

input ChangelogChangeUpdateInput {
  column: String
  oldValue: String
  newValue: String
  logId: ID
}

input ChangelogChangeSortType {
  id: ObjectSortType
  idMin: ObjectSortType
  idMax: ObjectSortType
  column: ObjectSortType
  columnMin: ObjectSortType
  columnMax: ObjectSortType
  oldValue: ObjectSortType
  oldValueMin: ObjectSortType
  oldValueMax: ObjectSortType
  newValue: ObjectSortType
  newValueMin: ObjectSortType
  newValueMax: ObjectSortType
  logId: ObjectSortType
  logIdMin: ObjectSortType
  logIdMax: ObjectSortType
  updatedAt: ObjectSortType
  updatedAtMin: ObjectSortType
  updatedAtMax: ObjectSortType
  createdAt: ObjectSortType
  createdAtMin: ObjectSortType
  createdAtMax: ObjectSortType
  updatedBy: ObjectSortType
  updatedByMin: ObjectSortType
  updatedByMax: ObjectSortType
  createdBy: ObjectSortType
  createdByMin: ObjectSortType
  createdByMax: ObjectSortType
  log: ChangelogSortType
}

input ChangelogChangeFilterType {
  AND: [ChangelogChangeFilterType!]
  OR: [ChangelogChangeFilterType!]
  id: ID
  idMin: ID
  idMax: ID
  id_ne: ID
  idMin_ne: ID
  idMax_ne: ID
  id_gt: ID
  idMin_gt: ID
  idMax_gt: ID
  id_lt: ID
  idMin_lt: ID
  idMax_lt: ID
  id_gte: ID
  idMin_gte: ID
  idMax_gte: ID
  id_lte: ID
  idMin_lte: ID
  idMax_lte: ID
  id_in: [ID!]
  idMin_in: [ID!]
  idMax_in: [ID!]
  id_not_in: [ID!]
  idMin_not_in: [ID!]
  idMax_not_in: [ID!]
  id_null: Boolean
  column: String
  columnMin: String
  columnMax: String
  column_ne: String
  columnMin_ne: String
  columnMax_ne: String
  column_gt: String
  columnMin_gt: String
  columnMax_gt: String
  column_lt: String
  columnMin_lt: String
  columnMax_lt: String
  column_gte: String
  columnMin_gte: String
  columnMax_gte: String
  column_lte: String
  columnMin_lte: String
  columnMax_lte: String
  column_in: [String!]
  columnMin_in: [String!]
  columnMax_in: [String!]
  column_not_in: [String!]
  columnMin_not_in: [String!]
  columnMax_not_in: [String!]
  column_like: String
  columnMin_like: String
  columnMax_like: String
  column_prefix: String
  columnMin_prefix: String
  columnMax_prefix: String
  column_suffix: String
  columnMin_suffix: String
  columnMax_suffix: String
  column_null: Boolean
  oldValue: String
  oldValueMin: String
  oldValueMax: String
  oldValue_ne: String
  oldValueMin_ne: String
  oldValueMax_ne: String
  oldValue_gt: String
  oldValueMin_gt: String
  oldValueMax_gt: String
  oldValue_lt: String
  oldValueMin_lt: String
  oldValueMax_lt: String
  oldValue_gte: String
  oldValueMin_gte: String
  oldValueMax_gte: String
  oldValue_lte: String
  oldValueMin_lte: String
  oldValueMax_lte: String
  oldValue_in: [String!]
  oldValueMin_in: [String!]
  oldValueMax_in: [String!]
  oldValue_not_in: [String!]
  oldValueMin_not_in: [String!]
  oldValueMax_not_in: [String!]
  oldValue_like: String
  oldValueMin_like: String
  oldValueMax_like: String
  oldValue_prefix: String
  oldValueMin_prefix: String
  oldValueMax_prefix: String
  oldValue_suffix: String
  oldValueMin_suffix: String
  oldValueMax_suffix: String
  oldValue_null: Boolean
  newValue: String
  newValueMin: String
  newValueMax: String
  newValue_ne: String
  newValueMin_ne: String
  newValueMax_ne: String
  newValue_gt: String
  newValueMin_gt: String
  newValueMax_gt: String
  newValue_lt: String
  newValueMin_lt: String
  newValueMax_lt: String
  newValue_gte: String
  newValueMin_gte: String
  newValueMax_gte: String
  newValue_lte: String
  newValueMin_lte: String
  newValueMax_lte: String
  newValue_in: [String!]
  newValueMin_in: [String!]
  newValueMax_in: [String!]
  newValue_not_in: [String!]
  newValueMin_not_in: [String!]
  newValueMax_not_in: [String!]
  newValue_like: String
  newValueMin_like: String
  newValueMax_like: String
  newValue_prefix: String
  newValueMin_prefix: String
  newValueMax_prefix: String
  newValue_suffix: String
  newValueMin_suffix: String
  newValueMax_suffix: String
  newValue_null: Boolean
  logId: ID
  logIdMin: ID
  logIdMax: ID
  logId_ne: ID
  logIdMin_ne: ID
  logIdMax_ne: ID
  logId_gt: ID
  logIdMin_gt: ID
  logIdMax_gt: ID
  logId_lt: ID
  logIdMin_lt: ID
  logIdMax_lt: ID
  logId_gte: ID
  logIdMin_gte: ID
  logIdMax_gte: ID
  logId_lte: ID
  logIdMin_lte: ID
  logIdMax_lte: ID
  logId_in: [ID!]
  logIdMin_in: [ID!]
  logIdMax_in: [ID!]
  logId_not_in: [ID!]
  logIdMin_not_in: [ID!]
  logIdMax_not_in: [ID!]
  logId_null: Boolean
  updatedAt: Time
  updatedAtMin: Time
  updatedAtMax: Time
  updatedAt_ne: Time
  updatedAtMin_ne: Time
  updatedAtMax_ne: Time
  updatedAt_gt: Time
  updatedAtMin_gt: Time
  updatedAtMax_gt: Time
  updatedAt_lt: Time
  updatedAtMin_lt: Time
  updatedAtMax_lt: Time
  updatedAt_gte: Time
  updatedAtMin_gte: Time
  updatedAtMax_gte: Time
  updatedAt_lte: Time
  updatedAtMin_lte: Time
  updatedAtMax_lte: Time
  updatedAt_in: [Time!]
  updatedAtMin_in: [Time!]
  updatedAtMax_in: [Time!]
  updatedAt_not_in: [Time!]
  updatedAtMin_not_in: [Time!]
  updatedAtMax_not_in: [Time!]
  updatedAt_null: Boolean
  createdAt: Time
  createdAtMin: Time
  createdAtMax: Time
  createdAt_ne: Time
  createdAtMin_ne: Time
  createdAtMax_ne: Time
  createdAt_gt: Time
  createdAtMin_gt: Time
  createdAtMax_gt: Time
  createdAt_lt: Time
  createdAtMin_lt: Time
  createdAtMax_lt: Time
  createdAt_gte: Time
  createdAtMin_gte: Time
  createdAtMax_gte: Time
  createdAt_lte: Time
  createdAtMin_lte: Time
  createdAtMax_lte: Time
  createdAt_in: [Time!]
  createdAtMin_in: [Time!]
  createdAtMax_in: [Time!]
  createdAt_not_in: [Time!]
  createdAtMin_not_in: [Time!]
  createdAtMax_not_in: [Time!]
  createdAt_null: Boolean
  updatedBy: ID
  updatedByMin: ID
  updatedByMax: ID
  updatedBy_ne: ID
  updatedByMin_ne: ID
  updatedByMax_ne: ID
  updatedBy_gt: ID
  updatedByMin_gt: ID
  updatedByMax_gt: ID
  updatedBy_lt: ID
  updatedByMin_lt: ID
  updatedByMax_lt: ID
  updatedBy_gte: ID
  updatedByMin_gte: ID
  updatedByMax_gte: ID
  updatedBy_lte: ID
  updatedByMin_lte: ID
  updatedByMax_lte: ID
  updatedBy_in: [ID!]
  updatedByMin_in: [ID!]
  updatedByMax_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedByMin_not_in: [ID!]
  updatedByMax_not_in: [ID!]
  updatedBy_null: Boolean
  createdBy: ID
  createdByMin: ID
  createdByMax: ID
  createdBy_ne: ID
  createdByMin_ne: ID
  createdByMax_ne: ID
  createdBy_gt: ID
  createdByMin_gt: ID
  createdByMax_gt: ID
  createdBy_lt: ID
  createdByMin_lt: ID
  createdByMax_lt: ID
  createdBy_gte: ID
  createdByMin_gte: ID
  createdByMax_gte: ID
  createdBy_lte: ID
  createdByMin_lte: ID
  createdByMax_lte: ID
  createdBy_in: [ID!]
  createdByMin_in: [ID!]
  createdByMax_in: [ID!]
  createdBy_not_in: [ID!]
  createdByMin_not_in: [ID!]
  createdByMax_not_in: [ID!]
  createdBy_null: Boolean
  log: ChangelogFilterType
}

type ChangelogChangeResultType {
  items: [ChangelogChange!]!
  count: Int!
  aggregations: ChangelogChangeResultAggregations!
}

type ChangelogChangeResultAggregations {
  columnMin: String!
  columnMax: String!
  oldValueMin: String
  oldValueMax: String
  newValueMin: String
  newValueMax: String
}

input ChangelogCreateInput {
  id: ID
  entity: String!
  entityID: String!
  principalID: String
  type: ChangelogType!
  date: Time!
  changesIds: [ID!]
}

input ChangelogUpdateInput {
  entity: String
  entityID: String
  principalID: String
  type: ChangelogType
  date: Time
  changesIds: [ID!]
}

input ChangelogSortType {
  id: ObjectSortType
  idMin: ObjectSortType
  idMax: ObjectSortType
  entity: ObjectSortType
  entityMin: ObjectSortType
  entityMax: ObjectSortType
  entityID: ObjectSortType
  entityIDMin: ObjectSortType
  entityIDMax: ObjectSortType
  principalID: ObjectSortType
  principalIDMin: ObjectSortType
  principalIDMax: ObjectSortType
  type: ObjectSortType
  typeMin: ObjectSortType
  typeMax: ObjectSortType
  date: ObjectSortType
  dateMin: ObjectSortType
  dateMax: ObjectSortType
  updatedAt: ObjectSortType
  updatedAtMin: ObjectSortType
  updatedAtMax: ObjectSortType
  createdAt: ObjectSortType
  createdAtMin: ObjectSortType
  createdAtMax: ObjectSortType
  updatedBy: ObjectSortType
  updatedByMin: ObjectSortType
  updatedByMax: ObjectSortType
  createdBy: ObjectSortType
  createdByMin: ObjectSortType
  createdByMax: ObjectSortType
  changesIds: ObjectSortType
  changesIdsMin: ObjectSortType
  changesIdsMax: ObjectSortType
  changes: ChangelogChangeSortType
}

input ChangelogFilterType {
  AND: [ChangelogFilterType!]
  OR: [ChangelogFilterType!]
  id: ID
  idMin: ID
  idMax: ID
  id_ne: ID
  idMin_ne: ID
  idMax_ne: ID
  id_gt: ID
  idMin_gt: ID
  idMax_gt: ID
  id_lt: ID
  idMin_lt: ID
  idMax_lt: ID
  id_gte: ID
  idMin_gte: ID
  idMax_gte: ID
  id_lte: ID
  idMin_lte: ID
  idMax_lte: ID
  id_in: [ID!]
  idMin_in: [ID!]
  idMax_in: [ID!]
  id_not_in: [ID!]
  idMin_not_in: [ID!]
  idMax_not_in: [ID!]
  id_null: Boolean
  entity: String
  entityMin: String
  entityMax: String
  entity_ne: String
  entityMin_ne: String
  entityMax_ne: String
  entity_gt: String
  entityMin_gt: String
  entityMax_gt: String
  entity_lt: String
  entityMin_lt: String
  entityMax_lt: String
  entity_gte: String
  entityMin_gte: String
  entityMax_gte: String
  entity_lte: String
  entityMin_lte: String
  entityMax_lte: String
  entity_in: [String!]
  entityMin_in: [String!]
  entityMax_in: [String!]
  entity_not_in: [String!]
  entityMin_not_in: [String!]
  entityMax_not_in: [String!]
  entity_like: String
  entityMin_like: String
  entityMax_like: String
  entity_prefix: String
  entityMin_prefix: String
  entityMax_prefix: String
  entity_suffix: String
  entityMin_suffix: String
  entityMax_suffix: String
  entity_null: Boolean
  entityID: String
  entityIDMin: String
  entityIDMax: String
  entityID_ne: String
  entityIDMin_ne: String
  entityIDMax_ne: String
  entityID_gt: String
  entityIDMin_gt: String
  entityIDMax_gt: String
  entityID_lt: String
  entityIDMin_lt: String
  entityIDMax_lt: String
  entityID_gte: String
  entityIDMin_gte: String
  entityIDMax_gte: String
  entityID_lte: String
  entityIDMin_lte: String
  entityIDMax_lte: String
  entityID_in: [String!]
  entityIDMin_in: [String!]
  entityIDMax_in: [String!]
  entityID_not_in: [String!]
  entityIDMin_not_in: [String!]
  entityIDMax_not_in: [String!]
  entityID_like: String
  entityIDMin_like: String
  entityIDMax_like: String
  entityID_prefix: String
  entityIDMin_prefix: String
  entityIDMax_prefix: String
  entityID_suffix: String
  entityIDMin_suffix: String
  entityIDMax_suffix: String
  entityID_null: Boolean
  principalID: String
  principalIDMin: String
  principalIDMax: String
  principalID_ne: String
  principalIDMin_ne: String
  principalIDMax_ne: String
  principalID_gt: String
  principalIDMin_gt: String
  principalIDMax_gt: String
  principalID_lt: String
  principalIDMin_lt: String
  principalIDMax_lt: String
  principalID_gte: String
  principalIDMin_gte: String
  principalIDMax_gte: String
  principalID_lte: String
  principalIDMin_lte: String
  principalIDMax_lte: String
  principalID_in: [String!]
  principalIDMin_in: [String!]
  principalIDMax_in: [String!]
  principalID_not_in: [String!]
  principalIDMin_not_in: [String!]
  principalIDMax_not_in: [String!]
  principalID_like: String
  principalIDMin_like: String
  principalIDMax_like: String
  principalID_prefix: String
  principalIDMin_prefix: String
  principalIDMax_prefix: String
  principalID_suffix: String
  principalIDMin_suffix: String
  principalIDMax_suffix: String
  principalID_null: Boolean
  type: ChangelogType
  typeMin: ChangelogType
  typeMax: ChangelogType
  type_ne: ChangelogType
  typeMin_ne: ChangelogType
  typeMax_ne: ChangelogType
  type_gt: ChangelogType
  typeMin_gt: ChangelogType
  typeMax_gt: ChangelogType
  type_lt: ChangelogType
  typeMin_lt: ChangelogType
  typeMax_lt: ChangelogType
  type_gte: ChangelogType
  typeMin_gte: ChangelogType
  typeMax_gte: ChangelogType
  type_lte: ChangelogType
  typeMin_lte: ChangelogType
  typeMax_lte: ChangelogType
  type_in: [ChangelogType!]
  typeMin_in: [ChangelogType!]
  typeMax_in: [ChangelogType!]
  type_not_in: [ChangelogType!]
  typeMin_not_in: [ChangelogType!]
  typeMax_not_in: [ChangelogType!]
  type_null: Boolean
  date: Time
  dateMin: Time
  dateMax: Time
  date_ne: Time
  dateMin_ne: Time
  dateMax_ne: Time
  date_gt: Time
  dateMin_gt: Time
  dateMax_gt: Time
  date_lt: Time
  dateMin_lt: Time
  dateMax_lt: Time
  date_gte: Time
  dateMin_gte: Time
  dateMax_gte: Time
  date_lte: Time
  dateMin_lte: Time
  dateMax_lte: Time
  date_in: [Time!]
  dateMin_in: [Time!]
  dateMax_in: [Time!]
  date_not_in: [Time!]
  dateMin_not_in: [Time!]
  dateMax_not_in: [Time!]
  date_null: Boolean
  updatedAt: Time
  updatedAtMin: Time
  updatedAtMax: Time
  updatedAt_ne: Time
  updatedAtMin_ne: Time
  updatedAtMax_ne: Time
  updatedAt_gt: Time
  updatedAtMin_gt: Time
  updatedAtMax_gt: Time
  updatedAt_lt: Time
  updatedAtMin_lt: Time
  updatedAtMax_lt: Time
  updatedAt_gte: Time
  updatedAtMin_gte: Time
  updatedAtMax_gte: Time
  updatedAt_lte: Time
  updatedAtMin_lte: Time
  updatedAtMax_lte: Time
  updatedAt_in: [Time!]
  updatedAtMin_in: [Time!]
  updatedAtMax_in: [Time!]
  updatedAt_not_in: [Time!]
  updatedAtMin_not_in: [Time!]
  updatedAtMax_not_in: [Time!]
  updatedAt_null: Boolean
  createdAt: Time
  createdAtMin: Time
  createdAtMax: Time
  createdAt_ne: Time
  createdAtMin_ne: Time
  createdAtMax_ne: Time
  createdAt_gt: Time
  createdAtMin_gt: Time
  createdAtMax_gt: Time
  createdAt_lt: Time
  createdAtMin_lt: Time
  createdAtMax_lt: Time
  createdAt_gte: Time
  createdAtMin_gte: Time
  createdAtMax_gte: Time
  createdAt_lte: Time
  createdAtMin_lte: Time
  createdAtMax_lte: Time
  createdAt_in: [Time!]
  createdAtMin_in: [Time!]
  createdAtMax_in: [Time!]
  createdAt_not_in: [Time!]
  createdAtMin_not_in: [Time!]
  createdAtMax_not_in: [Time!]
  createdAt_null: Boolean
  updatedBy: ID
  updatedByMin: ID
  updatedByMax: ID
  updatedBy_ne: ID
  updatedByMin_ne: ID
  updatedByMax_ne: ID
  updatedBy_gt: ID
  updatedByMin_gt: ID
  updatedByMax_gt: ID
  updatedBy_lt: ID
  updatedByMin_lt: ID
  updatedByMax_lt: ID
  updatedBy_gte: ID
  updatedByMin_gte: ID
  updatedByMax_gte: ID
  updatedBy_lte: ID
  updatedByMin_lte: ID
  updatedByMax_lte: ID
  updatedBy_in: [ID!]
  updatedByMin_in: [ID!]
  updatedByMax_in: [ID!]
  updatedBy_not_in: [ID!]
  updatedByMin_not_in: [ID!]
  updatedByMax_not_in: [ID!]
  updatedBy_null: Boolean
  createdBy: ID
  createdByMin: ID
  createdByMax: ID
  createdBy_ne: ID
  createdByMin_ne: ID
  createdByMax_ne: ID
  createdBy_gt: ID
  createdByMin_gt: ID
  createdByMax_gt: ID
  createdBy_lt: ID
  createdByMin_lt: ID
  createdByMax_lt: ID
  createdBy_gte: ID
  createdByMin_gte: ID
  createdByMax_gte: ID
  createdBy_lte: ID
  createdByMin_lte: ID
  createdByMax_lte: ID
  createdBy_in: [ID!]
  createdByMin_in: [ID!]
  createdByMax_in: [ID!]
  createdBy_not_in: [ID!]
  createdByMin_not_in: [ID!]
  createdByMax_not_in: [ID!]
  createdBy_null: Boolean
  changes: ChangelogChangeFilterType
}

type ChangelogResultType {
  items: [Changelog!]!
  count: Int!
  aggregations: ChangelogResultAggregations!
}

type ChangelogResultAggregations {
  entityMin: String!
  entityMax: String!
  entityIDMin: String!
  entityIDMax: String!
  principalIDMin: String
  principalIDMax: String
}

type _Service {
  sdl: String
}

union _Entity = Changelog
`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Changelog_changesConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["q"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["q"] = arg2
	var arg3 []*ChangelogChangeSortType
	if tmp, ok := rawArgs["sort"]; ok {
		arg3, err = ec.unmarshalOChangelogChangeSortType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortTypeᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg3
	var arg4 *ChangelogChangeFilterType
	if tmp, ok := rawArgs["filter"]; ok {
		arg4, err = ec.unmarshalOChangelogChangeFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg4
	return args, nil
}

func (ec *executionContext) field_Mutation_createChangelogChange_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNChangelogChangeCreateInput2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createChangelog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNChangelogCreateInput2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChangelogChange_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChangelog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChangelogChange_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 map[string]interface{}
	if tmp, ok := rawArgs["input"]; ok {
		arg1, err = ec.unmarshalNChangelogChangeUpdateInput2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChangelog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 map[string]interface{}
	if tmp, ok := rawArgs["input"]; ok {
		arg1, err = ec.unmarshalNChangelogUpdateInput2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query__entities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []interface{}
	if tmp, ok := rawArgs["representations"]; ok {
		arg0, err = ec.unmarshalN_Any2ᚕinterfaceᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["representations"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_changelogChange_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["q"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["q"] = arg1
	var arg2 *ChangelogChangeFilterType
	if tmp, ok := rawArgs["filter"]; ok {
		arg2, err = ec.unmarshalOChangelogChangeFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_changelogChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["q"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["q"] = arg2
	var arg3 []*ChangelogChangeSortType
	if tmp, ok := rawArgs["sort"]; ok {
		arg3, err = ec.unmarshalOChangelogChangeSortType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortTypeᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg3
	var arg4 *ChangelogChangeFilterType
	if tmp, ok := rawArgs["filter"]; ok {
		arg4, err = ec.unmarshalOChangelogChangeFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_changelog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["q"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["q"] = arg1
	var arg2 *ChangelogFilterType
	if tmp, ok := rawArgs["filter"]; ok {
		arg2, err = ec.unmarshalOChangelogFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_changelogs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["q"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["q"] = arg2
	var arg3 []*ChangelogSortType
	if tmp, ok := rawArgs["sort"]; ok {
		arg3, err = ec.unmarshalOChangelogSortType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogSortTypeᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg3
	var arg4 *ChangelogFilterType
	if tmp, ok := rawArgs["filter"]; ok {
		arg4, err = ec.unmarshalOChangelogFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg4
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Changelog_id(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_entity(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_entityID(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_principalID(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrincipalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_type(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ChangelogType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_date(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_changes(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Changelog().Changes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ChangelogChange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogChange2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_createdAt(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_updatedBy(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_createdBy(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_changesIds(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Changelog().ChangesIds(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Changelog_changesConnection(ctx context.Context, field graphql.CollectedField, obj *Changelog) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Changelog",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Changelog_changesConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Changelog().ChangesConnection(rctx, obj, args["offset"].(*int), args["limit"].(*int), args["q"].(*string), args["sort"].([]*ChangelogChangeSortType), args["filter"].(*ChangelogChangeFilterType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ChangelogChangeResultType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogChangeResultType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeResultType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChange_id(ctx context.Context, field graphql.CollectedField, obj *ChangelogChange) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChange_column(ctx context.Context, field graphql.CollectedField, obj *ChangelogChange) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Column, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChange_oldValue(ctx context.Context, field graphql.CollectedField, obj *ChangelogChange) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChange_newValue(ctx context.Context, field graphql.CollectedField, obj *ChangelogChange) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChange_log(ctx context.Context, field graphql.CollectedField, obj *ChangelogChange) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChange",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ChangelogChange().Log(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Changelog)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOChangelog2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelog(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChange_logId(ctx context.Context, field graphql.CollectedField, obj *ChangelogChange) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChange_updatedAt(ctx context.Context, field graphql.CollectedField, obj *ChangelogChange) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChange_createdAt(ctx context.Context, field graphql.CollectedField, obj *ChangelogChange) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChange_updatedBy(ctx context.Context, field graphql.CollectedField, obj *ChangelogChange) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChange_createdBy(ctx context.Context, field graphql.CollectedField, obj *ChangelogChange) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChangeResultAggregations_columnMin(ctx context.Context, field graphql.CollectedField, obj *ChangelogChangeResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChangeResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColumnMin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChangeResultAggregations_columnMax(ctx context.Context, field graphql.CollectedField, obj *ChangelogChangeResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChangeResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColumnMax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChangeResultAggregations_oldValueMin(ctx context.Context, field graphql.CollectedField, obj *ChangelogChangeResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChangeResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValueMin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChangeResultAggregations_oldValueMax(ctx context.Context, field graphql.CollectedField, obj *ChangelogChangeResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChangeResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValueMax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChangeResultAggregations_newValueMin(ctx context.Context, field graphql.CollectedField, obj *ChangelogChangeResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChangeResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValueMin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChangeResultAggregations_newValueMax(ctx context.Context, field graphql.CollectedField, obj *ChangelogChangeResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChangeResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValueMax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChangeResultType_items(ctx context.Context, field graphql.CollectedField, obj *ChangelogChangeResultType) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChangeResultType",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ChangelogChangeResultType().Items(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ChangelogChange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogChange2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChangeResultType_count(ctx context.Context, field graphql.CollectedField, obj *ChangelogChangeResultType) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChangeResultType",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ChangelogChangeResultType().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogChangeResultType_aggregations(ctx context.Context, field graphql.CollectedField, obj *ChangelogChangeResultType) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogChangeResultType",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ChangelogChangeResultType().Aggregations(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ChangelogChangeResultAggregations)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogChangeResultAggregations2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeResultAggregations(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogResultAggregations_entityMin(ctx context.Context, field graphql.CollectedField, obj *ChangelogResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntityMin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogResultAggregations_entityMax(ctx context.Context, field graphql.CollectedField, obj *ChangelogResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntityMax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogResultAggregations_entityIDMin(ctx context.Context, field graphql.CollectedField, obj *ChangelogResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntityIDMin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogResultAggregations_entityIDMax(ctx context.Context, field graphql.CollectedField, obj *ChangelogResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntityIDMax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogResultAggregations_principalIDMin(ctx context.Context, field graphql.CollectedField, obj *ChangelogResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrincipalIDMin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogResultAggregations_principalIDMax(ctx context.Context, field graphql.CollectedField, obj *ChangelogResultAggregations) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogResultAggregations",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrincipalIDMax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogResultType_items(ctx context.Context, field graphql.CollectedField, obj *ChangelogResultType) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogResultType",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ChangelogResultType().Items(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Changelog)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelog2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogResultType_count(ctx context.Context, field graphql.CollectedField, obj *ChangelogResultType) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogResultType",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ChangelogResultType().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangelogResultType_aggregations(ctx context.Context, field graphql.CollectedField, obj *ChangelogResultType) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ChangelogResultType",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ChangelogResultType().Aggregations(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ChangelogResultAggregations)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogResultAggregations2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogResultAggregations(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createChangelogChange(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createChangelogChange_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateChangelogChange(rctx, args["input"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ChangelogChange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogChange2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChange(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateChangelogChange(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateChangelogChange_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateChangelogChange(rctx, args["id"].(string), args["input"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ChangelogChange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogChange2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChange(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteChangelogChange(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteChangelogChange_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteChangelogChange(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ChangelogChange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogChange2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChange(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteAllChangelogChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteAllChangelogChanges(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createChangelog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createChangelog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateChangelog(rctx, args["input"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Changelog)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelog2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelog(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateChangelog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateChangelog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateChangelog(rctx, args["id"].(string), args["input"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Changelog)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelog2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelog(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteChangelog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteChangelog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteChangelog(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Changelog)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelog2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelog(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteAllChangelogs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteAllChangelogs(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._service(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*_Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN_Service2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐ_Service(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__entities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__entities_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._entities(rctx, args["representations"].([]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]_Entity)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN_Entity2ᚕgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐ_Entity(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_changelogChange(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_changelogChange_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ChangelogChange(rctx, args["id"].(*string), args["q"].(*string), args["filter"].(*ChangelogChangeFilterType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ChangelogChange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOChangelogChange2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChange(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_changelogChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_changelogChanges_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ChangelogChanges(rctx, args["offset"].(*int), args["limit"].(*int), args["q"].(*string), args["sort"].([]*ChangelogChangeSortType), args["filter"].(*ChangelogChangeFilterType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ChangelogChangeResultType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogChangeResultType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeResultType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_changelog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_changelog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Changelog(rctx, args["id"].(*string), args["q"].(*string), args["filter"].(*ChangelogFilterType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Changelog)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOChangelog2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelog(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_changelogs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_changelogs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Changelogs(rctx, args["offset"].(*int), args["limit"].(*int), args["q"].(*string), args["sort"].([]*ChangelogSortType), args["filter"].(*ChangelogFilterType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ChangelogResultType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChangelogResultType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogResultType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) __Service_sdl(ctx context.Context, field graphql.CollectedField, obj *_Service) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "_Service",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sdl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputChangelogChangeFilterType(ctx context.Context, obj interface{}) (ChangelogChangeFilterType, error) {
	var it ChangelogChangeFilterType
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "AND":
			var err error
			it.And, err = ec.unmarshalOChangelogChangeFilterType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOChangelogChangeFilterType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin":
			var err error
			it.IDMin, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax":
			var err error
			it.IDMax, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ne":
			var err error
			it.IDNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_ne":
			var err error
			it.IDMinNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_ne":
			var err error
			it.IDMaxNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_gt":
			var err error
			it.IDMinGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_gt":
			var err error
			it.IDMaxGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_lt":
			var err error
			it.IDMinLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_lt":
			var err error
			it.IDMaxLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_gte":
			var err error
			it.IDMinGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_gte":
			var err error
			it.IDMaxGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_lte":
			var err error
			it.IDMinLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_lte":
			var err error
			it.IDMaxLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_in":
			var err error
			it.IDMinIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_in":
			var err error
			it.IDMaxIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_not_in":
			var err error
			it.IDMinNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_not_in":
			var err error
			it.IDMaxNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_null":
			var err error
			it.IDNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "column":
			var err error
			it.Column, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin":
			var err error
			it.ColumnMin, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax":
			var err error
			it.ColumnMax, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_ne":
			var err error
			it.ColumnNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin_ne":
			var err error
			it.ColumnMinNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax_ne":
			var err error
			it.ColumnMaxNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_gt":
			var err error
			it.ColumnGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin_gt":
			var err error
			it.ColumnMinGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax_gt":
			var err error
			it.ColumnMaxGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_lt":
			var err error
			it.ColumnLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin_lt":
			var err error
			it.ColumnMinLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax_lt":
			var err error
			it.ColumnMaxLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_gte":
			var err error
			it.ColumnGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin_gte":
			var err error
			it.ColumnMinGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax_gte":
			var err error
			it.ColumnMaxGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_lte":
			var err error
			it.ColumnLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin_lte":
			var err error
			it.ColumnMinLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax_lte":
			var err error
			it.ColumnMaxLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_in":
			var err error
			it.ColumnIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin_in":
			var err error
			it.ColumnMinIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax_in":
			var err error
			it.ColumnMaxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_not_in":
			var err error
			it.ColumnNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin_not_in":
			var err error
			it.ColumnMinNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax_not_in":
			var err error
			it.ColumnMaxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_like":
			var err error
			it.ColumnLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin_like":
			var err error
			it.ColumnMinLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax_like":
			var err error
			it.ColumnMaxLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_prefix":
			var err error
			it.ColumnPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin_prefix":
			var err error
			it.ColumnMinPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax_prefix":
			var err error
			it.ColumnMaxPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_suffix":
			var err error
			it.ColumnSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin_suffix":
			var err error
			it.ColumnMinSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax_suffix":
			var err error
			it.ColumnMaxSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "column_null":
			var err error
			it.ColumnNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue":
			var err error
			it.OldValue, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin":
			var err error
			it.OldValueMin, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax":
			var err error
			it.OldValueMax, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_ne":
			var err error
			it.OldValueNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin_ne":
			var err error
			it.OldValueMinNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax_ne":
			var err error
			it.OldValueMaxNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_gt":
			var err error
			it.OldValueGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin_gt":
			var err error
			it.OldValueMinGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax_gt":
			var err error
			it.OldValueMaxGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_lt":
			var err error
			it.OldValueLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin_lt":
			var err error
			it.OldValueMinLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax_lt":
			var err error
			it.OldValueMaxLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_gte":
			var err error
			it.OldValueGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin_gte":
			var err error
			it.OldValueMinGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax_gte":
			var err error
			it.OldValueMaxGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_lte":
			var err error
			it.OldValueLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin_lte":
			var err error
			it.OldValueMinLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax_lte":
			var err error
			it.OldValueMaxLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_in":
			var err error
			it.OldValueIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin_in":
			var err error
			it.OldValueMinIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax_in":
			var err error
			it.OldValueMaxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_not_in":
			var err error
			it.OldValueNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin_not_in":
			var err error
			it.OldValueMinNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax_not_in":
			var err error
			it.OldValueMaxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_like":
			var err error
			it.OldValueLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin_like":
			var err error
			it.OldValueMinLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax_like":
			var err error
			it.OldValueMaxLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_prefix":
			var err error
			it.OldValuePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin_prefix":
			var err error
			it.OldValueMinPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax_prefix":
			var err error
			it.OldValueMaxPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_suffix":
			var err error
			it.OldValueSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin_suffix":
			var err error
			it.OldValueMinSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax_suffix":
			var err error
			it.OldValueMaxSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue_null":
			var err error
			it.OldValueNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue":
			var err error
			it.NewValue, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin":
			var err error
			it.NewValueMin, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax":
			var err error
			it.NewValueMax, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_ne":
			var err error
			it.NewValueNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin_ne":
			var err error
			it.NewValueMinNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax_ne":
			var err error
			it.NewValueMaxNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_gt":
			var err error
			it.NewValueGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin_gt":
			var err error
			it.NewValueMinGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax_gt":
			var err error
			it.NewValueMaxGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_lt":
			var err error
			it.NewValueLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin_lt":
			var err error
			it.NewValueMinLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax_lt":
			var err error
			it.NewValueMaxLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_gte":
			var err error
			it.NewValueGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin_gte":
			var err error
			it.NewValueMinGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax_gte":
			var err error
			it.NewValueMaxGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_lte":
			var err error
			it.NewValueLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin_lte":
			var err error
			it.NewValueMinLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax_lte":
			var err error
			it.NewValueMaxLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_in":
			var err error
			it.NewValueIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin_in":
			var err error
			it.NewValueMinIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax_in":
			var err error
			it.NewValueMaxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_not_in":
			var err error
			it.NewValueNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin_not_in":
			var err error
			it.NewValueMinNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax_not_in":
			var err error
			it.NewValueMaxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_like":
			var err error
			it.NewValueLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin_like":
			var err error
			it.NewValueMinLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax_like":
			var err error
			it.NewValueMaxLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_prefix":
			var err error
			it.NewValuePrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin_prefix":
			var err error
			it.NewValueMinPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax_prefix":
			var err error
			it.NewValueMaxPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_suffix":
			var err error
			it.NewValueSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin_suffix":
			var err error
			it.NewValueMinSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax_suffix":
			var err error
			it.NewValueMaxSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue_null":
			var err error
			it.NewValueNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "logId":
			var err error
			it.LogID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMin":
			var err error
			it.LogIDMin, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMax":
			var err error
			it.LogIDMax, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logId_ne":
			var err error
			it.LogIDNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMin_ne":
			var err error
			it.LogIDMinNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMax_ne":
			var err error
			it.LogIDMaxNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logId_gt":
			var err error
			it.LogIDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMin_gt":
			var err error
			it.LogIDMinGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMax_gt":
			var err error
			it.LogIDMaxGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logId_lt":
			var err error
			it.LogIDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMin_lt":
			var err error
			it.LogIDMinLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMax_lt":
			var err error
			it.LogIDMaxLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logId_gte":
			var err error
			it.LogIDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMin_gte":
			var err error
			it.LogIDMinGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMax_gte":
			var err error
			it.LogIDMaxGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logId_lte":
			var err error
			it.LogIDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMin_lte":
			var err error
			it.LogIDMinLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMax_lte":
			var err error
			it.LogIDMaxLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logId_in":
			var err error
			it.LogIDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMin_in":
			var err error
			it.LogIDMinIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMax_in":
			var err error
			it.LogIDMaxIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "logId_not_in":
			var err error
			it.LogIDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMin_not_in":
			var err error
			it.LogIDMinNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMax_not_in":
			var err error
			it.LogIDMaxNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "logId_null":
			var err error
			it.LogIDNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error
			it.UpdatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin":
			var err error
			it.UpdatedAtMin, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax":
			var err error
			it.UpdatedAtMax, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_ne":
			var err error
			it.UpdatedAtNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_ne":
			var err error
			it.UpdatedAtMinNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_ne":
			var err error
			it.UpdatedAtMaxNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gt":
			var err error
			it.UpdatedAtGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_gt":
			var err error
			it.UpdatedAtMinGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_gt":
			var err error
			it.UpdatedAtMaxGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lt":
			var err error
			it.UpdatedAtLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_lt":
			var err error
			it.UpdatedAtMinLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_lt":
			var err error
			it.UpdatedAtMaxLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gte":
			var err error
			it.UpdatedAtGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_gte":
			var err error
			it.UpdatedAtMinGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_gte":
			var err error
			it.UpdatedAtMaxGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lte":
			var err error
			it.UpdatedAtLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_lte":
			var err error
			it.UpdatedAtMinLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_lte":
			var err error
			it.UpdatedAtMaxLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_in":
			var err error
			it.UpdatedAtIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_in":
			var err error
			it.UpdatedAtMinIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_in":
			var err error
			it.UpdatedAtMaxIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_not_in":
			var err error
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_not_in":
			var err error
			it.UpdatedAtMinNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_not_in":
			var err error
			it.UpdatedAtMaxNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_null":
			var err error
			it.UpdatedAtNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin":
			var err error
			it.CreatedAtMin, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax":
			var err error
			it.CreatedAtMax, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_ne":
			var err error
			it.CreatedAtNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_ne":
			var err error
			it.CreatedAtMinNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_ne":
			var err error
			it.CreatedAtMaxNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gt":
			var err error
			it.CreatedAtGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_gt":
			var err error
			it.CreatedAtMinGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_gt":
			var err error
			it.CreatedAtMaxGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lt":
			var err error
			it.CreatedAtLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_lt":
			var err error
			it.CreatedAtMinLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_lt":
			var err error
			it.CreatedAtMaxLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gte":
			var err error
			it.CreatedAtGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_gte":
			var err error
			it.CreatedAtMinGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_gte":
			var err error
			it.CreatedAtMaxGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lte":
			var err error
			it.CreatedAtLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_lte":
			var err error
			it.CreatedAtMinLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_lte":
			var err error
			it.CreatedAtMaxLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_in":
			var err error
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_in":
			var err error
			it.CreatedAtMinIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_in":
			var err error
			it.CreatedAtMaxIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not_in":
			var err error
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_not_in":
			var err error
			it.CreatedAtMinNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_not_in":
			var err error
			it.CreatedAtMaxNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_null":
			var err error
			it.CreatedAtNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy":
			var err error
			it.UpdatedBy, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin":
			var err error
			it.UpdatedByMin, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax":
			var err error
			it.UpdatedByMax, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_ne":
			var err error
			it.UpdatedByNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_ne":
			var err error
			it.UpdatedByMinNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_ne":
			var err error
			it.UpdatedByMaxNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_gt":
			var err error
			it.UpdatedByGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_gt":
			var err error
			it.UpdatedByMinGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_gt":
			var err error
			it.UpdatedByMaxGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_lt":
			var err error
			it.UpdatedByLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_lt":
			var err error
			it.UpdatedByMinLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_lt":
			var err error
			it.UpdatedByMaxLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_gte":
			var err error
			it.UpdatedByGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_gte":
			var err error
			it.UpdatedByMinGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_gte":
			var err error
			it.UpdatedByMaxGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_lte":
			var err error
			it.UpdatedByLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_lte":
			var err error
			it.UpdatedByMinLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_lte":
			var err error
			it.UpdatedByMaxLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_in":
			var err error
			it.UpdatedByIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_in":
			var err error
			it.UpdatedByMinIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_in":
			var err error
			it.UpdatedByMaxIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_not_in":
			var err error
			it.UpdatedByNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_not_in":
			var err error
			it.UpdatedByMinNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_not_in":
			var err error
			it.UpdatedByMaxNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_null":
			var err error
			it.UpdatedByNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy":
			var err error
			it.CreatedBy, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin":
			var err error
			it.CreatedByMin, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax":
			var err error
			it.CreatedByMax, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_ne":
			var err error
			it.CreatedByNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_ne":
			var err error
			it.CreatedByMinNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_ne":
			var err error
			it.CreatedByMaxNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_gt":
			var err error
			it.CreatedByGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_gt":
			var err error
			it.CreatedByMinGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_gt":
			var err error
			it.CreatedByMaxGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_lt":
			var err error
			it.CreatedByLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_lt":
			var err error
			it.CreatedByMinLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_lt":
			var err error
			it.CreatedByMaxLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_gte":
			var err error
			it.CreatedByGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_gte":
			var err error
			it.CreatedByMinGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_gte":
			var err error
			it.CreatedByMaxGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_lte":
			var err error
			it.CreatedByLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_lte":
			var err error
			it.CreatedByMinLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_lte":
			var err error
			it.CreatedByMaxLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_in":
			var err error
			it.CreatedByIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_in":
			var err error
			it.CreatedByMinIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_in":
			var err error
			it.CreatedByMaxIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_in":
			var err error
			it.CreatedByNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_not_in":
			var err error
			it.CreatedByMinNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_not_in":
			var err error
			it.CreatedByMaxNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_null":
			var err error
			it.CreatedByNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "log":
			var err error
			it.Log, err = ec.unmarshalOChangelogFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChangelogChangeSortType(ctx context.Context, obj interface{}) (ChangelogChangeSortType, error) {
	var it ChangelogChangeSortType
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin":
			var err error
			it.IDMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax":
			var err error
			it.IDMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "column":
			var err error
			it.Column, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMin":
			var err error
			it.ColumnMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "columnMax":
			var err error
			it.ColumnMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValue":
			var err error
			it.OldValue, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMin":
			var err error
			it.OldValueMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "oldValueMax":
			var err error
			it.OldValueMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValue":
			var err error
			it.NewValue, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMin":
			var err error
			it.NewValueMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "newValueMax":
			var err error
			it.NewValueMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "logId":
			var err error
			it.LogID, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMin":
			var err error
			it.LogIDMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "logIdMax":
			var err error
			it.LogIDMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error
			it.UpdatedAt, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin":
			var err error
			it.UpdatedAtMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax":
			var err error
			it.UpdatedAtMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin":
			var err error
			it.CreatedAtMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax":
			var err error
			it.CreatedAtMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy":
			var err error
			it.UpdatedBy, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin":
			var err error
			it.UpdatedByMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax":
			var err error
			it.UpdatedByMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy":
			var err error
			it.CreatedBy, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin":
			var err error
			it.CreatedByMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax":
			var err error
			it.CreatedByMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "log":
			var err error
			it.Log, err = ec.unmarshalOChangelogSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogSortType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChangelogFilterType(ctx context.Context, obj interface{}) (ChangelogFilterType, error) {
	var it ChangelogFilterType
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "AND":
			var err error
			it.And, err = ec.unmarshalOChangelogFilterType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOChangelogFilterType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin":
			var err error
			it.IDMin, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax":
			var err error
			it.IDMax, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ne":
			var err error
			it.IDNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_ne":
			var err error
			it.IDMinNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_ne":
			var err error
			it.IDMaxNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_gt":
			var err error
			it.IDMinGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_gt":
			var err error
			it.IDMaxGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_lt":
			var err error
			it.IDMinLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_lt":
			var err error
			it.IDMaxLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_gte":
			var err error
			it.IDMinGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_gte":
			var err error
			it.IDMaxGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_lte":
			var err error
			it.IDMinLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_lte":
			var err error
			it.IDMaxLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_in":
			var err error
			it.IDMinIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_in":
			var err error
			it.IDMaxIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin_not_in":
			var err error
			it.IDMinNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax_not_in":
			var err error
			it.IDMaxNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_null":
			var err error
			it.IDNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity":
			var err error
			it.Entity, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin":
			var err error
			it.EntityMin, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax":
			var err error
			it.EntityMax, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_ne":
			var err error
			it.EntityNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin_ne":
			var err error
			it.EntityMinNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax_ne":
			var err error
			it.EntityMaxNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_gt":
			var err error
			it.EntityGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin_gt":
			var err error
			it.EntityMinGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax_gt":
			var err error
			it.EntityMaxGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_lt":
			var err error
			it.EntityLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin_lt":
			var err error
			it.EntityMinLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax_lt":
			var err error
			it.EntityMaxLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_gte":
			var err error
			it.EntityGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin_gte":
			var err error
			it.EntityMinGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax_gte":
			var err error
			it.EntityMaxGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_lte":
			var err error
			it.EntityLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin_lte":
			var err error
			it.EntityMinLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax_lte":
			var err error
			it.EntityMaxLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_in":
			var err error
			it.EntityIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin_in":
			var err error
			it.EntityMinIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax_in":
			var err error
			it.EntityMaxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_not_in":
			var err error
			it.EntityNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin_not_in":
			var err error
			it.EntityMinNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax_not_in":
			var err error
			it.EntityMaxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_like":
			var err error
			it.EntityLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin_like":
			var err error
			it.EntityMinLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax_like":
			var err error
			it.EntityMaxLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_prefix":
			var err error
			it.EntityPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin_prefix":
			var err error
			it.EntityMinPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax_prefix":
			var err error
			it.EntityMaxPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_suffix":
			var err error
			it.EntitySuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin_suffix":
			var err error
			it.EntityMinSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax_suffix":
			var err error
			it.EntityMaxSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity_null":
			var err error
			it.EntityNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID":
			var err error
			it.EntityID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin":
			var err error
			it.EntityIDMin, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax":
			var err error
			it.EntityIDMax, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_ne":
			var err error
			it.EntityIDNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin_ne":
			var err error
			it.EntityIDMinNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax_ne":
			var err error
			it.EntityIDMaxNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_gt":
			var err error
			it.EntityIDGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin_gt":
			var err error
			it.EntityIDMinGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax_gt":
			var err error
			it.EntityIDMaxGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_lt":
			var err error
			it.EntityIDLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin_lt":
			var err error
			it.EntityIDMinLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax_lt":
			var err error
			it.EntityIDMaxLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_gte":
			var err error
			it.EntityIDGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin_gte":
			var err error
			it.EntityIDMinGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax_gte":
			var err error
			it.EntityIDMaxGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_lte":
			var err error
			it.EntityIDLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin_lte":
			var err error
			it.EntityIDMinLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax_lte":
			var err error
			it.EntityIDMaxLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_in":
			var err error
			it.EntityIDIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin_in":
			var err error
			it.EntityIDMinIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax_in":
			var err error
			it.EntityIDMaxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_not_in":
			var err error
			it.EntityIDNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin_not_in":
			var err error
			it.EntityIDMinNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax_not_in":
			var err error
			it.EntityIDMaxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_like":
			var err error
			it.EntityIDLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin_like":
			var err error
			it.EntityIDMinLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax_like":
			var err error
			it.EntityIDMaxLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_prefix":
			var err error
			it.EntityIDPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin_prefix":
			var err error
			it.EntityIDMinPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax_prefix":
			var err error
			it.EntityIDMaxPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_suffix":
			var err error
			it.EntityIDSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin_suffix":
			var err error
			it.EntityIDMinSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax_suffix":
			var err error
			it.EntityIDMaxSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID_null":
			var err error
			it.EntityIDNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID":
			var err error
			it.PrincipalID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin":
			var err error
			it.PrincipalIDMin, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax":
			var err error
			it.PrincipalIDMax, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_ne":
			var err error
			it.PrincipalIDNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin_ne":
			var err error
			it.PrincipalIDMinNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax_ne":
			var err error
			it.PrincipalIDMaxNe, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_gt":
			var err error
			it.PrincipalIDGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin_gt":
			var err error
			it.PrincipalIDMinGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax_gt":
			var err error
			it.PrincipalIDMaxGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_lt":
			var err error
			it.PrincipalIDLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin_lt":
			var err error
			it.PrincipalIDMinLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax_lt":
			var err error
			it.PrincipalIDMaxLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_gte":
			var err error
			it.PrincipalIDGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin_gte":
			var err error
			it.PrincipalIDMinGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax_gte":
			var err error
			it.PrincipalIDMaxGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_lte":
			var err error
			it.PrincipalIDLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin_lte":
			var err error
			it.PrincipalIDMinLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax_lte":
			var err error
			it.PrincipalIDMaxLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_in":
			var err error
			it.PrincipalIDIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin_in":
			var err error
			it.PrincipalIDMinIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax_in":
			var err error
			it.PrincipalIDMaxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_not_in":
			var err error
			it.PrincipalIDNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin_not_in":
			var err error
			it.PrincipalIDMinNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax_not_in":
			var err error
			it.PrincipalIDMaxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_like":
			var err error
			it.PrincipalIDLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin_like":
			var err error
			it.PrincipalIDMinLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax_like":
			var err error
			it.PrincipalIDMaxLike, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_prefix":
			var err error
			it.PrincipalIDPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin_prefix":
			var err error
			it.PrincipalIDMinPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax_prefix":
			var err error
			it.PrincipalIDMaxPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_suffix":
			var err error
			it.PrincipalIDSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin_suffix":
			var err error
			it.PrincipalIDMinSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax_suffix":
			var err error
			it.PrincipalIDMaxSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID_null":
			var err error
			it.PrincipalIDNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMin":
			var err error
			it.TypeMin, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMax":
			var err error
			it.TypeMax, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_ne":
			var err error
			it.TypeNe, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMin_ne":
			var err error
			it.TypeMinNe, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMax_ne":
			var err error
			it.TypeMaxNe, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_gt":
			var err error
			it.TypeGt, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMin_gt":
			var err error
			it.TypeMinGt, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMax_gt":
			var err error
			it.TypeMaxGt, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_lt":
			var err error
			it.TypeLt, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMin_lt":
			var err error
			it.TypeMinLt, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMax_lt":
			var err error
			it.TypeMaxLt, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_gte":
			var err error
			it.TypeGte, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMin_gte":
			var err error
			it.TypeMinGte, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMax_gte":
			var err error
			it.TypeMaxGte, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_lte":
			var err error
			it.TypeLte, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMin_lte":
			var err error
			it.TypeMinLte, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMax_lte":
			var err error
			it.TypeMaxLte, err = ec.unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_in":
			var err error
			it.TypeIn, err = ec.unmarshalOChangelogType2ᚕgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMin_in":
			var err error
			it.TypeMinIn, err = ec.unmarshalOChangelogType2ᚕgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMax_in":
			var err error
			it.TypeMaxIn, err = ec.unmarshalOChangelogType2ᚕgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_not_in":
			var err error
			it.TypeNotIn, err = ec.unmarshalOChangelogType2ᚕgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMin_not_in":
			var err error
			it.TypeMinNotIn, err = ec.unmarshalOChangelogType2ᚕgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMax_not_in":
			var err error
			it.TypeMaxNotIn, err = ec.unmarshalOChangelogType2ᚕgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "type_null":
			var err error
			it.TypeNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "date":
			var err error
			it.Date, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMin":
			var err error
			it.DateMin, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMax":
			var err error
			it.DateMax, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "date_ne":
			var err error
			it.DateNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMin_ne":
			var err error
			it.DateMinNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMax_ne":
			var err error
			it.DateMaxNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "date_gt":
			var err error
			it.DateGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMin_gt":
			var err error
			it.DateMinGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMax_gt":
			var err error
			it.DateMaxGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "date_lt":
			var err error
			it.DateLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMin_lt":
			var err error
			it.DateMinLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMax_lt":
			var err error
			it.DateMaxLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "date_gte":
			var err error
			it.DateGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMin_gte":
			var err error
			it.DateMinGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMax_gte":
			var err error
			it.DateMaxGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "date_lte":
			var err error
			it.DateLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMin_lte":
			var err error
			it.DateMinLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMax_lte":
			var err error
			it.DateMaxLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "date_in":
			var err error
			it.DateIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMin_in":
			var err error
			it.DateMinIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMax_in":
			var err error
			it.DateMaxIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "date_not_in":
			var err error
			it.DateNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMin_not_in":
			var err error
			it.DateMinNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMax_not_in":
			var err error
			it.DateMaxNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "date_null":
			var err error
			it.DateNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error
			it.UpdatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin":
			var err error
			it.UpdatedAtMin, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax":
			var err error
			it.UpdatedAtMax, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_ne":
			var err error
			it.UpdatedAtNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_ne":
			var err error
			it.UpdatedAtMinNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_ne":
			var err error
			it.UpdatedAtMaxNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gt":
			var err error
			it.UpdatedAtGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_gt":
			var err error
			it.UpdatedAtMinGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_gt":
			var err error
			it.UpdatedAtMaxGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lt":
			var err error
			it.UpdatedAtLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_lt":
			var err error
			it.UpdatedAtMinLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_lt":
			var err error
			it.UpdatedAtMaxLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gte":
			var err error
			it.UpdatedAtGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_gte":
			var err error
			it.UpdatedAtMinGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_gte":
			var err error
			it.UpdatedAtMaxGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lte":
			var err error
			it.UpdatedAtLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_lte":
			var err error
			it.UpdatedAtMinLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_lte":
			var err error
			it.UpdatedAtMaxLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_in":
			var err error
			it.UpdatedAtIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_in":
			var err error
			it.UpdatedAtMinIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_in":
			var err error
			it.UpdatedAtMaxIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_not_in":
			var err error
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin_not_in":
			var err error
			it.UpdatedAtMinNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax_not_in":
			var err error
			it.UpdatedAtMaxNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_null":
			var err error
			it.UpdatedAtNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin":
			var err error
			it.CreatedAtMin, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax":
			var err error
			it.CreatedAtMax, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_ne":
			var err error
			it.CreatedAtNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_ne":
			var err error
			it.CreatedAtMinNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_ne":
			var err error
			it.CreatedAtMaxNe, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gt":
			var err error
			it.CreatedAtGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_gt":
			var err error
			it.CreatedAtMinGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_gt":
			var err error
			it.CreatedAtMaxGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lt":
			var err error
			it.CreatedAtLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_lt":
			var err error
			it.CreatedAtMinLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_lt":
			var err error
			it.CreatedAtMaxLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gte":
			var err error
			it.CreatedAtGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_gte":
			var err error
			it.CreatedAtMinGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_gte":
			var err error
			it.CreatedAtMaxGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lte":
			var err error
			it.CreatedAtLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_lte":
			var err error
			it.CreatedAtMinLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_lte":
			var err error
			it.CreatedAtMaxLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_in":
			var err error
			it.CreatedAtIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_in":
			var err error
			it.CreatedAtMinIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_in":
			var err error
			it.CreatedAtMaxIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not_in":
			var err error
			it.CreatedAtNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin_not_in":
			var err error
			it.CreatedAtMinNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax_not_in":
			var err error
			it.CreatedAtMaxNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_null":
			var err error
			it.CreatedAtNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy":
			var err error
			it.UpdatedBy, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin":
			var err error
			it.UpdatedByMin, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax":
			var err error
			it.UpdatedByMax, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_ne":
			var err error
			it.UpdatedByNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_ne":
			var err error
			it.UpdatedByMinNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_ne":
			var err error
			it.UpdatedByMaxNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_gt":
			var err error
			it.UpdatedByGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_gt":
			var err error
			it.UpdatedByMinGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_gt":
			var err error
			it.UpdatedByMaxGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_lt":
			var err error
			it.UpdatedByLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_lt":
			var err error
			it.UpdatedByMinLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_lt":
			var err error
			it.UpdatedByMaxLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_gte":
			var err error
			it.UpdatedByGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_gte":
			var err error
			it.UpdatedByMinGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_gte":
			var err error
			it.UpdatedByMaxGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_lte":
			var err error
			it.UpdatedByLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_lte":
			var err error
			it.UpdatedByMinLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_lte":
			var err error
			it.UpdatedByMaxLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_in":
			var err error
			it.UpdatedByIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_in":
			var err error
			it.UpdatedByMinIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_in":
			var err error
			it.UpdatedByMaxIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_not_in":
			var err error
			it.UpdatedByNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin_not_in":
			var err error
			it.UpdatedByMinNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax_not_in":
			var err error
			it.UpdatedByMaxNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy_null":
			var err error
			it.UpdatedByNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy":
			var err error
			it.CreatedBy, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin":
			var err error
			it.CreatedByMin, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax":
			var err error
			it.CreatedByMax, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_ne":
			var err error
			it.CreatedByNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_ne":
			var err error
			it.CreatedByMinNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_ne":
			var err error
			it.CreatedByMaxNe, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_gt":
			var err error
			it.CreatedByGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_gt":
			var err error
			it.CreatedByMinGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_gt":
			var err error
			it.CreatedByMaxGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_lt":
			var err error
			it.CreatedByLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_lt":
			var err error
			it.CreatedByMinLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_lt":
			var err error
			it.CreatedByMaxLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_gte":
			var err error
			it.CreatedByGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_gte":
			var err error
			it.CreatedByMinGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_gte":
			var err error
			it.CreatedByMaxGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_lte":
			var err error
			it.CreatedByLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_lte":
			var err error
			it.CreatedByMinLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_lte":
			var err error
			it.CreatedByMaxLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_in":
			var err error
			it.CreatedByIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_in":
			var err error
			it.CreatedByMinIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_in":
			var err error
			it.CreatedByMaxIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_not_in":
			var err error
			it.CreatedByNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin_not_in":
			var err error
			it.CreatedByMinNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax_not_in":
			var err error
			it.CreatedByMaxNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy_null":
			var err error
			it.CreatedByNull, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "changes":
			var err error
			it.Changes, err = ec.unmarshalOChangelogChangeFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChangelogSortType(ctx context.Context, obj interface{}) (ChangelogSortType, error) {
	var it ChangelogSortType
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMin":
			var err error
			it.IDMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "idMax":
			var err error
			it.IDMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "entity":
			var err error
			it.Entity, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMin":
			var err error
			it.EntityMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityMax":
			var err error
			it.EntityMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityID":
			var err error
			it.EntityID, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMin":
			var err error
			it.EntityIDMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityIDMax":
			var err error
			it.EntityIDMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalID":
			var err error
			it.PrincipalID, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMin":
			var err error
			it.PrincipalIDMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "principalIDMax":
			var err error
			it.PrincipalIDMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMin":
			var err error
			it.TypeMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeMax":
			var err error
			it.TypeMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "date":
			var err error
			it.Date, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMin":
			var err error
			it.DateMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateMax":
			var err error
			it.DateMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error
			it.UpdatedAt, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMin":
			var err error
			it.UpdatedAtMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtMax":
			var err error
			it.UpdatedAtMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMin":
			var err error
			it.CreatedAtMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtMax":
			var err error
			it.CreatedAtMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedBy":
			var err error
			it.UpdatedBy, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMin":
			var err error
			it.UpdatedByMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedByMax":
			var err error
			it.UpdatedByMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy":
			var err error
			it.CreatedBy, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMin":
			var err error
			it.CreatedByMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdByMax":
			var err error
			it.CreatedByMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "changesIds":
			var err error
			it.ChangesIds, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "changesIdsMin":
			var err error
			it.ChangesIdsMin, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "changesIdsMax":
			var err error
			it.ChangesIdsMax, err = ec.unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
			if err != nil {
				return it, err
			}
		case "changes":
			var err error
			it.Changes, err = ec.unmarshalOChangelogChangeSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) __Entity(ctx context.Context, sel ast.SelectionSet, obj _Entity) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *Changelog:
		if obj == nil {
			return graphql.Null
		}
		return ec._Changelog(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var changelogImplementors = []string{"Changelog", "_Entity"}

func (ec *executionContext) _Changelog(ctx context.Context, sel ast.SelectionSet, obj *Changelog) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, changelogImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Changelog")
		case "id":
			out.Values[i] = ec._Changelog_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "entity":
			out.Values[i] = ec._Changelog_entity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "entityID":
			out.Values[i] = ec._Changelog_entityID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "principalID":
			out.Values[i] = ec._Changelog_principalID(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Changelog_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "date":
			out.Values[i] = ec._Changelog_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "changes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Changelog_changes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "updatedAt":
			out.Values[i] = ec._Changelog_updatedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Changelog_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedBy":
			out.Values[i] = ec._Changelog_updatedBy(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._Changelog_createdBy(ctx, field, obj)
		case "changesIds":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Changelog_changesIds(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "changesConnection":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Changelog_changesConnection(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var changelogChangeImplementors = []string{"ChangelogChange"}

func (ec *executionContext) _ChangelogChange(ctx context.Context, sel ast.SelectionSet, obj *ChangelogChange) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, changelogChangeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangelogChange")
		case "id":
			out.Values[i] = ec._ChangelogChange_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "column":
			out.Values[i] = ec._ChangelogChange_column(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "oldValue":
			out.Values[i] = ec._ChangelogChange_oldValue(ctx, field, obj)
		case "newValue":
			out.Values[i] = ec._ChangelogChange_newValue(ctx, field, obj)
		case "log":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ChangelogChange_log(ctx, field, obj)
				return res
			})
		case "logId":
			out.Values[i] = ec._ChangelogChange_logId(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._ChangelogChange_updatedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ChangelogChange_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedBy":
			out.Values[i] = ec._ChangelogChange_updatedBy(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._ChangelogChange_createdBy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var changelogChangeResultAggregationsImplementors = []string{"ChangelogChangeResultAggregations"}

func (ec *executionContext) _ChangelogChangeResultAggregations(ctx context.Context, sel ast.SelectionSet, obj *ChangelogChangeResultAggregations) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, changelogChangeResultAggregationsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangelogChangeResultAggregations")
		case "columnMin":
			out.Values[i] = ec._ChangelogChangeResultAggregations_columnMin(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "columnMax":
			out.Values[i] = ec._ChangelogChangeResultAggregations_columnMax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "oldValueMin":
			out.Values[i] = ec._ChangelogChangeResultAggregations_oldValueMin(ctx, field, obj)
		case "oldValueMax":
			out.Values[i] = ec._ChangelogChangeResultAggregations_oldValueMax(ctx, field, obj)
		case "newValueMin":
			out.Values[i] = ec._ChangelogChangeResultAggregations_newValueMin(ctx, field, obj)
		case "newValueMax":
			out.Values[i] = ec._ChangelogChangeResultAggregations_newValueMax(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var changelogChangeResultTypeImplementors = []string{"ChangelogChangeResultType"}

func (ec *executionContext) _ChangelogChangeResultType(ctx context.Context, sel ast.SelectionSet, obj *ChangelogChangeResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, changelogChangeResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangelogChangeResultType")
		case "items":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ChangelogChangeResultType_items(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "count":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ChangelogChangeResultType_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "aggregations":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ChangelogChangeResultType_aggregations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var changelogResultAggregationsImplementors = []string{"ChangelogResultAggregations"}

func (ec *executionContext) _ChangelogResultAggregations(ctx context.Context, sel ast.SelectionSet, obj *ChangelogResultAggregations) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, changelogResultAggregationsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangelogResultAggregations")
		case "entityMin":
			out.Values[i] = ec._ChangelogResultAggregations_entityMin(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "entityMax":
			out.Values[i] = ec._ChangelogResultAggregations_entityMax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "entityIDMin":
			out.Values[i] = ec._ChangelogResultAggregations_entityIDMin(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "entityIDMax":
			out.Values[i] = ec._ChangelogResultAggregations_entityIDMax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "principalIDMin":
			out.Values[i] = ec._ChangelogResultAggregations_principalIDMin(ctx, field, obj)
		case "principalIDMax":
			out.Values[i] = ec._ChangelogResultAggregations_principalIDMax(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var changelogResultTypeImplementors = []string{"ChangelogResultType"}

func (ec *executionContext) _ChangelogResultType(ctx context.Context, sel ast.SelectionSet, obj *ChangelogResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, changelogResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangelogResultType")
		case "items":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ChangelogResultType_items(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "count":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ChangelogResultType_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "aggregations":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ChangelogResultType_aggregations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createChangelogChange":
			out.Values[i] = ec._Mutation_createChangelogChange(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChangelogChange":
			out.Values[i] = ec._Mutation_updateChangelogChange(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteChangelogChange":
			out.Values[i] = ec._Mutation_deleteChangelogChange(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteAllChangelogChanges":
			out.Values[i] = ec._Mutation_deleteAllChangelogChanges(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createChangelog":
			out.Values[i] = ec._Mutation_createChangelog(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChangelog":
			out.Values[i] = ec._Mutation_updateChangelog(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteChangelog":
			out.Values[i] = ec._Mutation_deleteChangelog(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteAllChangelogs":
			out.Values[i] = ec._Mutation_deleteAllChangelogs(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "_service":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__service(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_entities":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__entities(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "changelogChange":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_changelogChange(ctx, field)
				return res
			})
		case "changelogChanges":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_changelogChanges(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "changelog":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_changelog(ctx, field)
				return res
			})
		case "changelogs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_changelogs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var _ServiceImplementors = []string{"_Service"}

func (ec *executionContext) __Service(ctx context.Context, sel ast.SelectionSet, obj *_Service) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, _ServiceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_Service")
		case "sdl":
			out.Values[i] = ec.__Service_sdl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNChangelog2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelog(ctx context.Context, sel ast.SelectionSet, v Changelog) graphql.Marshaler {
	return ec._Changelog(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangelog2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogᚄ(ctx context.Context, sel ast.SelectionSet, v []*Changelog) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChangelog2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelog(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNChangelog2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelog(ctx context.Context, sel ast.SelectionSet, v *Changelog) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Changelog(ctx, sel, v)
}

func (ec *executionContext) marshalNChangelogChange2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChange(ctx context.Context, sel ast.SelectionSet, v ChangelogChange) graphql.Marshaler {
	return ec._ChangelogChange(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangelogChange2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeᚄ(ctx context.Context, sel ast.SelectionSet, v []*ChangelogChange) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChangelogChange2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChange(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNChangelogChange2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChange(ctx context.Context, sel ast.SelectionSet, v *ChangelogChange) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChangelogChange(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChangelogChangeCreateInput2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return v.(map[string]interface{}), nil
}

func (ec *executionContext) unmarshalNChangelogChangeFilterType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx context.Context, v interface{}) (ChangelogChangeFilterType, error) {
	return ec.unmarshalInputChangelogChangeFilterType(ctx, v)
}

func (ec *executionContext) unmarshalNChangelogChangeFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx context.Context, v interface{}) (*ChangelogChangeFilterType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNChangelogChangeFilterType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNChangelogChangeResultAggregations2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeResultAggregations(ctx context.Context, sel ast.SelectionSet, v ChangelogChangeResultAggregations) graphql.Marshaler {
	return ec._ChangelogChangeResultAggregations(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangelogChangeResultAggregations2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeResultAggregations(ctx context.Context, sel ast.SelectionSet, v *ChangelogChangeResultAggregations) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChangelogChangeResultAggregations(ctx, sel, v)
}

func (ec *executionContext) marshalNChangelogChangeResultType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeResultType(ctx context.Context, sel ast.SelectionSet, v ChangelogChangeResultType) graphql.Marshaler {
	return ec._ChangelogChangeResultType(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangelogChangeResultType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeResultType(ctx context.Context, sel ast.SelectionSet, v *ChangelogChangeResultType) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChangelogChangeResultType(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChangelogChangeSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortType(ctx context.Context, v interface{}) (ChangelogChangeSortType, error) {
	return ec.unmarshalInputChangelogChangeSortType(ctx, v)
}

func (ec *executionContext) unmarshalNChangelogChangeSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortType(ctx context.Context, v interface{}) (*ChangelogChangeSortType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNChangelogChangeSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortType(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNChangelogChangeUpdateInput2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return v.(map[string]interface{}), nil
}

func (ec *executionContext) unmarshalNChangelogCreateInput2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return v.(map[string]interface{}), nil
}

func (ec *executionContext) unmarshalNChangelogFilterType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterType(ctx context.Context, v interface{}) (ChangelogFilterType, error) {
	return ec.unmarshalInputChangelogFilterType(ctx, v)
}

func (ec *executionContext) unmarshalNChangelogFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterType(ctx context.Context, v interface{}) (*ChangelogFilterType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNChangelogFilterType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNChangelogResultAggregations2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogResultAggregations(ctx context.Context, sel ast.SelectionSet, v ChangelogResultAggregations) graphql.Marshaler {
	return ec._ChangelogResultAggregations(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangelogResultAggregations2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogResultAggregations(ctx context.Context, sel ast.SelectionSet, v *ChangelogResultAggregations) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChangelogResultAggregations(ctx, sel, v)
}

func (ec *executionContext) marshalNChangelogResultType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogResultType(ctx context.Context, sel ast.SelectionSet, v ChangelogResultType) graphql.Marshaler {
	return ec._ChangelogResultType(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangelogResultType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogResultType(ctx context.Context, sel ast.SelectionSet, v *ChangelogResultType) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChangelogResultType(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChangelogSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogSortType(ctx context.Context, v interface{}) (ChangelogSortType, error) {
	return ec.unmarshalInputChangelogSortType(ctx, v)
}

func (ec *executionContext) unmarshalNChangelogSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogSortType(ctx context.Context, v interface{}) (*ChangelogSortType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNChangelogSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogSortType(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNChangelogType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx context.Context, v interface{}) (ChangelogType, error) {
	var res ChangelogType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNChangelogType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx context.Context, sel ast.SelectionSet, v ChangelogType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNChangelogUpdateInput2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return v.(map[string]interface{}), nil
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.marshalNTime2timeᚐTime(ctx, sel, *v)
}

func (ec *executionContext) unmarshalN_Any2interface(ctx context.Context, v interface{}) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return Unmarshal_Any(v)
}

func (ec *executionContext) marshalN_Any2interface(ctx context.Context, sel ast.SelectionSet, v interface{}) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := Marshal_Any(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN_Any2ᚕinterfaceᚄ(ctx context.Context, v interface{}) ([]interface{}, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]interface{}, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN_Any2interface(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN_Any2ᚕinterfaceᚄ(ctx context.Context, sel ast.SelectionSet, v []interface{}) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalN_Any2interface(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalN_Entity2ᚕgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐ_Entity(ctx context.Context, sel ast.SelectionSet, v []_Entity) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalO_Entity2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐ_Entity(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN_Service2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐ_Service(ctx context.Context, sel ast.SelectionSet, v _Service) graphql.Marshaler {
	return ec.__Service(ctx, sel, &v)
}

func (ec *executionContext) marshalN_Service2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐ_Service(ctx context.Context, sel ast.SelectionSet, v *_Service) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.__Service(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) marshalOChangelog2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelog(ctx context.Context, sel ast.SelectionSet, v Changelog) graphql.Marshaler {
	return ec._Changelog(ctx, sel, &v)
}

func (ec *executionContext) marshalOChangelog2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelog(ctx context.Context, sel ast.SelectionSet, v *Changelog) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Changelog(ctx, sel, v)
}

func (ec *executionContext) marshalOChangelogChange2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChange(ctx context.Context, sel ast.SelectionSet, v ChangelogChange) graphql.Marshaler {
	return ec._ChangelogChange(ctx, sel, &v)
}

func (ec *executionContext) marshalOChangelogChange2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChange(ctx context.Context, sel ast.SelectionSet, v *ChangelogChange) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChangelogChange(ctx, sel, v)
}

func (ec *executionContext) unmarshalOChangelogChangeFilterType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx context.Context, v interface{}) (ChangelogChangeFilterType, error) {
	return ec.unmarshalInputChangelogChangeFilterType(ctx, v)
}

func (ec *executionContext) unmarshalOChangelogChangeFilterType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterTypeᚄ(ctx context.Context, v interface{}) ([]*ChangelogChangeFilterType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*ChangelogChangeFilterType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNChangelogChangeFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOChangelogChangeFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx context.Context, v interface{}) (*ChangelogChangeFilterType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChangelogChangeFilterType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeFilterType(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOChangelogChangeSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortType(ctx context.Context, v interface{}) (ChangelogChangeSortType, error) {
	return ec.unmarshalInputChangelogChangeSortType(ctx, v)
}

func (ec *executionContext) unmarshalOChangelogChangeSortType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortTypeᚄ(ctx context.Context, v interface{}) ([]*ChangelogChangeSortType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*ChangelogChangeSortType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNChangelogChangeSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOChangelogChangeSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortType(ctx context.Context, v interface{}) (*ChangelogChangeSortType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChangelogChangeSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogChangeSortType(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOChangelogFilterType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterType(ctx context.Context, v interface{}) (ChangelogFilterType, error) {
	return ec.unmarshalInputChangelogFilterType(ctx, v)
}

func (ec *executionContext) unmarshalOChangelogFilterType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterTypeᚄ(ctx context.Context, v interface{}) ([]*ChangelogFilterType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*ChangelogFilterType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNChangelogFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOChangelogFilterType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterType(ctx context.Context, v interface{}) (*ChangelogFilterType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChangelogFilterType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogFilterType(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOChangelogSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogSortType(ctx context.Context, v interface{}) (ChangelogSortType, error) {
	return ec.unmarshalInputChangelogSortType(ctx, v)
}

func (ec *executionContext) unmarshalOChangelogSortType2ᚕᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogSortTypeᚄ(ctx context.Context, v interface{}) ([]*ChangelogSortType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*ChangelogSortType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNChangelogSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogSortType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOChangelogSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogSortType(ctx context.Context, v interface{}) (*ChangelogSortType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChangelogSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogSortType(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOChangelogType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx context.Context, v interface{}) (ChangelogType, error) {
	var res ChangelogType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOChangelogType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx context.Context, sel ast.SelectionSet, v ChangelogType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOChangelogType2ᚕgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogTypeᚄ(ctx context.Context, v interface{}) ([]ChangelogType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]ChangelogType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNChangelogType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOChangelogType2ᚕgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []ChangelogType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChangelogType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx context.Context, v interface{}) (*ChangelogType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChangelogType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOChangelogType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐChangelogType(ctx context.Context, sel ast.SelectionSet, v *ChangelogType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOObjectSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx context.Context, v interface{}) (ObjectSortType, error) {
	var res ObjectSortType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOObjectSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx context.Context, sel ast.SelectionSet, v ObjectSortType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx context.Context, v interface{}) (*ObjectSortType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOObjectSortType2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOObjectSortType2ᚖgithubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐObjectSortType(ctx context.Context, sel ast.SelectionSet, v *ObjectSortType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return graphql.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx context.Context, v interface{}) ([]*time.Time, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*time.Time, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNTime2ᚖtimeᚐTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx context.Context, sel ast.SelectionSet, v []*time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2ᚖtimeᚐTime(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTime2timeᚐTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTime2timeᚐTime(ctx, sel, *v)
}

func (ec *executionContext) marshalO_Entity2githubᚗcomᚋgraphqlᚑservicesᚋgraphqlᚑormᚑchangelogᚋgenᚐ_Entity(ctx context.Context, sel ast.SelectionSet, v _Entity) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.__Entity(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
